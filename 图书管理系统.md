# 图书管理系统的设计与实现

---

## 一. 需求分析

### 1.1 用户类型


- 系统管理员(usertype = 1)
- 图书管理员(usertype = 2)
- 普通读者(usertype = 3)

> 基于用户类型判断功能是否开放给该用户

### 1.2 模块分析

|模块|输入数据|输出数据|处理逻辑|
|----|:-----:|:-----:|-------|
|用户登录|用户名，密码|登陆成功/失败提示|验证三次失败则退出|
|图书查询|书号/书名/作者/出版社|图书详细信息|通过索引查询|
|借书处理|读者号，书号|借书成功/失败提示|检查读者借书限额及图书藏量|

### 1.3 非法输入处理
- 用户密码需为8位字母+数字组合，否则提示重输
- 书号输入时需验证是否存在，不存在则提示错误

---

## 二. 概要设计

```mermaid
flowchart TD
    n1(["Main函数"]) --> n6["login"]
    n6 --> n2["usermanage"] & n3["readermanage"] & n4["bookmanage"] & n5["bookcirculation"]
    n2 --> n7["add_user"] & n8["modify_user"] & n9["delete_user"] & n10["show_user"] & n11["modify_password"]
    n3 --> n13["load_reader"]
    n13 --> n14["add_reader"] & n15["modify_reader"] & n16["delete_reader"] & n17["search_reader"] & n18["show_reader"]
    n7 --> n12["write_user"]
    n9 --> n12
    n10 --> n12
    n18 --> n19["write_reader"]
    n17 --> n19
    n16 --> n19
    n15 --> n19
    n14 --> n19
    n4 --> n20["load_book"]
    n20 --> n21["load_index"]
    n21 --> n22["createid_index"]
    n22 --> n23["add_book"] & n24["modify_book"] & n25["search_book"] & n26["summary"]
    n25 --> n27["id_search"] & n28["name_search"] & n29["author_search"] & n30["press_search"]
    n5 --> n31["loadbook"]
    n31 --> n32["createid_index"]
    n32 --> n33["load_circulation"]
    n33 --> n34["lend_book"] & n35["return_book"]
    n34 --> n36["write_reader"]
    n35 --> n36
    n27 --> n37["binary_search"]
    n11 --> n38["password_check"]
    n38 --> n12
    n8 --> n38
```

>注: 系统调用函数关系图

---

## 三. 详细设计

### 3.1 结构体

#### 3.1.1 用户结构
```c
typedef struct User       //用户结构
{
    int id;
    char password[20];
    int usertype;
} User;
```

#### 3.1.2 读者结构
```c
typedef struct            //读者结构
{
    int id;
    char name[20];
    char workunit[20];
    long phonenumber;
    int available;
    int borrownum;
} Reader;
```

#### 3.1.3 图书结构
```c
typedef struct book       //图书结构
{
    int recordnum;
    int id;
    char name[20];
    char author[20];
    char press[20];
    int collectionnum;
    int lendnum;
    int pointer_1;
    int pointer_2;
    int pointer_3;
} Book;
```

#### 3.1.4 书名次关键字索引结构
```c
typedef struct name_index
{
    char name[20];
    int head;
    int length;
} Name_index;
```

#### 3.1.5 作者次关键字索引结构
```c
typedef struct author_index
{
    char author[20];
    int head;
    int length;
} Author_index;
```

#### 3.1.6 出版社次关键字索引结构
```c
typedef struct press_index
{
    char press[20];
    int head;
    int length;
} Press_index;
```

#### 3.1.7 id索引结构
```c
typedef struct id_index
{
    int id;
    int recordnum;
} Id_index;
```

#### 3.1.8 图书流通索引结构
```c
typedef struct circulation
{
    int id;
    int bookid;
    char lendtime[20];
    char returntime[20];
    int state;
} Circulation;
```
---

### 3.2 部分函数流程图

#### 3.2.1 login函数流程图
```mermaid
graph TD
    Start[开始] --> Initialize[初始化 try = 0]
    Initialize --> LoopCheck{try < 3?}
    LoopCheck -- 是 --> InputID[输入用户名 id]
    InputID --> InputPass[输入密码 password]
    InputPass --> InitP[初始化 p = head->next]
    InitP --> TraverseCheck{p != NULL?}
    TraverseCheck -- 是 --> MatchCheck{p的id和密码匹配?}
    MatchCheck -- 是 --> SetUser[设置 usertype 和 user_id]
    SetUser --> PrintSuccess[输出登录成功]
    PrintSuccess --> Return[返回]
    MatchCheck -- 否 --> NextP[p = p->next]
    NextP --> TraverseCheck
    TraverseCheck -- 否 --> PrintFail[输出登录失败]
    PrintFail --> IncTry[try++]
    IncTry --> LoopCheck
    LoopCheck -- 否 --> Exit[输出失败次数过多并退出]
    Exit --> End[结束]
```

#### 3.2.2 二分法函数流程图
```mermaid
graph TD
    Start[开始] --> InitBooknum[初始化计数器]
    InitBooknum --> ForLoop[/遍历数组/]
    ForLoop --> ForCondition{"元素有效?"}
    ForCondition -- 是 --> IncBooknum[计数器+1]
    IncBooknum --> ForLoop
    ForCondition -- 否 --> SetBounds[设置边界]
    SetBounds --> WhileCheck{left ≤ right?}
    
    WhileCheck -- 是 --> CalcMid["mid = (left+right)/2"]
    CalcMid --> Compare{比较}
    
    Compare --> ConditionA["目标ID < 当前ID"]
    ConditionA -- 是 --> MoveRight[右边界左移]
    MoveRight --> WhileCheck
    
    Compare --> ConditionB["目标ID > 当前ID"]
    ConditionB -- 是 --> MoveLeft[左边界右移]
    MoveLeft --> WhileCheck
    
    Compare --> ConditionC["匹配成功"]
    ConditionC -- 是 --> ReturnFound[返回索引]
    
    WhileCheck -- 否 --> PrintNotFound[输出错误]
    PrintNotFound --> ReturnFail[返回-1]

```
---

## 四. 测试阶段

### 4.1 登录功能测试

|测试内容|输入|预期结果|实际结果|
|-------|----|-------|--------|
|正确登录|用户名:1998017,密码:1234567q|进入主菜单|成功|
|密码错误三次|用户名:test,密码:test|退出|成功|

### 4.2 借书功能测试

| 测试内容 | 输入 | 预期结果 | 实际结果 |
| -------- | ---- | -------- | -------- |
|超限借书|读者号:1998017(已借10本), 书号:1021|提示“借书数量已达上限”|成功|
|存书不足|书号:1021(存量0)|提示“该书已借完”|成功|

---

## 五. 调试分析

> 在编写代码的过程中，我遇到了很多问题，也出现过一些bug
> 下面我举几个调试过程中遇到的困难 or bug以及它的解决方法

### 5.1 指针三兄弟
>What's 指针？

当我打开《**Linux下程序设计基础综合实验**》想要看一下有关索引的介绍时，~~我人傻le~~，看了半天也没看懂这**三个指针**是干嘛用的。

**苦思冥想**了半天(~~通义千问谢谢你~~)，终于***想***明白是怎么回事了。

原来啊，指针指向的就是**上一本**和它有**同样性质**(书名/作者/出版社相同)的书呀！
这下我就可以解决使用索引查找的问题了！！

具体呢，要先从**链头指针**找起，然后顺藤摸瓜(就像链表一样)，就可以找到所有有**同样性质**的书了。

不多废话(~~内心os:不想一句一句解释~~)，上代码(以name_search为例):

```c
void name_search(void)
{
    char name[20];
    printf("请输入要查询的图书名：");
    scanf("%s", name);
    int namenum = 0;
    for (int i = 0; name_index[i].head != '\0'; i++)
    {
        namenum++;
    }
    int bookplace = 0; // (已修改)
    for (int i = 0; i < namenum; i++)
    {
        if ((strcmp(name, name_index[i].name)) == 0)
        {
            bookplace = i;
            break;
        }
    }
    printf("----------------\n");
    printf("记录号为: %d\n", name_index[bookplace].head);
    int recordnum = name_index[bookplace].head;
    printf("图书名: %s\n", book[recordnum - 1].name);
    printf("作者: %s\n", book[recordnum - 1].author);
    printf("出版社: %s\n", book[recordnum - 1].press);
    printf("藏书量: %d\n", book[recordnum - 1].collectionnum);
    printf("借出量: %d\n", book[recordnum - 1].lendnum);


    while (recordnum != 0)
    {
        recordnum = book[recordnum - 1].pointer_1;
        if (recordnum == 0)
        {
            break;
        }
        printf("----------------\n");
        printf("记录号为: %d\n", recordnum);
        printf("图书名: %s\n", book[recordnum - 1].name);
        printf("作者: %s\n", book[recordnum - 1].author);
        printf("出版社: %s\n", book[recordnum - 1].press);
        printf("藏书量: %d\n", book[recordnum - 1].collectionnum);
        printf("借出量: %d\n", book[recordnum - 1].lendnum);
    }
}
```
呃呃

你以为到这就结束了？

***NONONO***

其实我和三兄弟的爱恨情仇才刚刚开始

### 5.1.1 找不到指针
>如何确定指针的值？

解决完前面的问题，我立刻转战下一个函数 **add_book**

嗯，***十分的简单***，***十分的容易***。

**嗯？！！！不对！！！**

添加书是不是也要知道后面的**三个指针**呢？
怎么知道？不知道。

emmmmmmm，于是我又想了半天

~~于是下面的代码就自动蹦出来了(bushi)~~
```c
int booknum = 0;
    int nameposition = 0;  //指针一
    int authorposition = 0;//指针二
    int pressposition = 0; //指针三

    for (int i = 0; book[i].id != '\0'; i++)
    {
        if (book[i].id == temp.id)
        {
            printf("图书号重复\n");
            return;
        }

        if (strcmp(book[i].name, temp.name) == 0)
        {
            nameposition = i + 1;
            //printf("nameposition = %d\n", nameposition);
        }

        if (strcmp(book[i].author, temp.author) == 0)
        {
            authorposition = i + 1;
            //printf("authorposition = %d\n", authorposition);
        }

        if (strcmp(book[i].press, temp.press) == 0)
        {
            pressposition = i + 1;
            //printf("pressposition = %d\n", pressposition);
        }
        booknum++;
    }
```
我还是解释一下吧

简单来说，就是如果有和这本书的**名字/作者/出版社**相同的书
那么就记录下它的位置，这样在后面添加书的时候，就可以直接使用**这个位置**来作为它的指针了。

很简单吧，我当时**就 是 想 不 到** ：>

### 5.1.2 关键字，你在哪？

明天见emmm，明天继续更，好像小说一样呢


